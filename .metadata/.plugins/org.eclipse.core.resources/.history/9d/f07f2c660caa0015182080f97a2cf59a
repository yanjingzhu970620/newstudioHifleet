package com.hifleet.lnfo.layer;

import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;
import java.util.concurrent.Executors;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import android.annotation.SuppressLint;
import android.app.ActionBar.LayoutParams;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.graphics.Path;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.drawable.BitmapDrawable;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.LinearLayout;
import android.widget.PopupWindow;
import android.widget.TextView;

import com.hifleet.R;
import com.hifleet.activity.ShipInfoActivity;
import com.hifleet.adapter.ShipsListAdapter;
import com.hifleet.adapter.TeamShipsListAdapter;
import com.hifleet.bean.HeartBeatBean;
import com.hifleet.bean.ShipsBean;
import com.hifleet.bean.lableBean;
import com.hifleet.bean.loginSession;
import com.hifleet.map.AnimateDraggingMapThread;
import com.hifleet.map.ITileSource;
import com.hifleet.map.IndexConstants;
import com.hifleet.map.LatLon;
import com.hifleet.map.MapTileAdapter;
import com.hifleet.map.MapTileLayer.IMapRefreshCallback;
import com.hifleet.map.OsmandApplication;
import com.hifleet.map.OsmandMapLayer;
import com.hifleet.map.OsmandMapTileView;
import com.hifleet.map.OsmandSettings;
import com.hifleet.map.QuadRect;
import com.hifleet.map.ResourceManager;
import com.hifleet.map.RotatedTileBox;
import com.hifleet.thread.MyTeamShipsThread;
import com.hifleet.utility.Cell;
import com.hifleet.utility.XmlParseUtility;

public class ShipsInfoLayer extends OsmandMapLayer implements
		IMapRefreshCallback {

	private QuadRect quadRect;

	private static Timer timer1 = null;
	private static TimerTask task1 = null;
	protected static final int emptyTileDivisor = 16;
	public static final int OVERZOOM_IN = 0;// 2;

	public static final int START_SHOW = IndexConstants.START_TO_SHOW_SHIPS_ZOOM;
	// public static boolean flag = true;

	public static boolean popflag = false;
	public static boolean allshipsrefresh = false;

	private final boolean mainMap;
	protected ITileSource map = null;
	protected MapTileAdapter mapTileAdapter = null;

	Paint paintBitmap, locationPaint;

	protected RectF bitmapToDraw = new RectF();

	protected Rect bitmapToZoom = new Rect();

	protected static OsmandMapTileView view;
	protected ResourceManager resourceManager;
	private OsmandSettings settings;
	AnimateDraggingMapThread thread;
	private boolean visible = true;
    private Timer timer=null;
    private TimerTask task=null;
	public static boolean lableadd = false;
	private List<HeartBeatBean> heartBeatBean = new ArrayList<HeartBeatBean>();
	private List<ShipsBean> _ships = new ArrayList<ShipsBean>();
	private List<ShipsBean> highlightedships = new ArrayList<ShipsBean>();//更新得到的高亮船舶。
	private List<ShipsBean> focusedships;//需要画的红色船舶
	
	public static List<ShipsBean> tap_ships = new ArrayList<ShipsBean>();// 存储当前点击的船舶
	public static List<ShipsBean> tap_shipsPoint = new ArrayList<ShipsBean>();//当前点击的船舶的历史点。
	public static List<ShipsBean> alltap_ships = new ArrayList<ShipsBean>();// 存储点击过的船舶
	public static List<ShipsBean> teamship = new ArrayList<ShipsBean>();// 存储船队列表当前点击的船
	public static List<ShipsBean> allteamship = new ArrayList<ShipsBean>();// 存储船队列表点击的所有船。//如果移动海图获取的是所有船队船舶就不需要了。
	public static List<ShipsBean> searchshipsBeans = new ArrayList<ShipsBean>();// 存储当前搜索到的船舶
	public static List<ShipsBean> allsearchshipsBeans = new ArrayList<ShipsBean>();// 存储搜索过的船舶
	
	public static List<lableBean> caddedlable = new ArrayList<lableBean>();//当前屏幕内标签
	
	
	private ArrayList<ShipsBean> _ships2Draw;// = new ArrayList<ShipsBean>();
	private Bitmap mShipIcon, mShipIcon1;
	
	Bitmap shipbm1tt, shipbm0tt,
	shipbm1tf, shipbm0tf,
	shipbm1ff, shipbm0ff;
   Bitmap shipbm1=null,shipbm0=null;
//   public long bwidth=0;
   
	private Paint paint_mid_point;
	private Paint shipShapPaint, shipShapHighPaint, shipShapPaint1,
			shipShapHighPaint1;
	// public static int justflag = 0;
	private Paint focusedShipShapePaint, focusedShipShapePaint1,
			focusedShipShapePaint2;

	private HashMap<String, Cell> _cellHashMap = new HashMap<String, Cell>();// 保存cellid和cell的对应关�?
	private HashMap<String, String> _shipCellMap = new HashMap<String, String>();// 保存mmsi和该船所在的cell的对应关�?

	// public List<ShipsBean> allteamShipsBeans = new ArrayList<ShipsBean>();

	public ShipsInfoLayer(boolean mainMap) {
		this.mainMap = mainMap;
	}

	@Override
	public boolean drawInScreenPixels() {
		return false;
	}

	DisplayMetrics dm;
	OsmandApplication app;

	@Override
	public void initLayer(OsmandMapTileView view) {
		this.view = view;
		settings = view.getSettings();
		resourceManager = view.getApplication().getResourceManager();
		thread = view.getAnimatedDraggingThread();
		dm = view.getResources().getDisplayMetrics();
		// System.out.println("==================");
		// paintBitmap = new Paint();
		// paintBitmap.setFilterBitmap(true);

		locationPaint = new Paint();
		locationPaint.setColor(view.getResources().getColor(R.color.black));
		locationPaint.setStyle(Style.FILL_AND_STROKE);
		locationPaint.setAntiAlias(true);
		locationPaint.setFilterBitmap(true);
		locationPaint.setDither(true);

		shipShapPaint = new Paint();
		shipShapPaint.setColor(0xff28e54e);
		shipShapPaint.setAntiAlias(true);
		shipShapPaint.setStrokeWidth(0);
		shipShapPaint.setStyle(Style.FILL_AND_STROKE);

		shipShapPaint1 = new Paint();
		shipShapPaint1.setColor(view.getResources().getColor(R.color.black));
		shipShapPaint1.setAntiAlias(true);
		shipShapPaint1.setStrokeWidth(3/2*dm.density);
		shipShapPaint1.setStyle(Style.STROKE);

		focusedShipShapePaint = new Paint();
		focusedShipShapePaint.setColor(view.getResources()
				.getColor(R.color.red));
		focusedShipShapePaint.setAntiAlias(true);
		focusedShipShapePaint.setStrokeWidth(0);
		focusedShipShapePaint.setStyle(Style.FILL_AND_STROKE);

		focusedShipShapePaint1 = new Paint();
		focusedShipShapePaint1.setColor(view.getResources().getColor(
				R.color.black));
		focusedShipShapePaint1.setAntiAlias(true);
		focusedShipShapePaint1.setStrokeWidth(3/2*dm.density);
		focusedShipShapePaint1.setStyle(Style.STROKE);

		focusedShipShapePaint2 = new Paint();
		focusedShipShapePaint2.setColor(view.getResources().getColor(
				R.color.red));
		focusedShipShapePaint2.setAntiAlias(true);
		focusedShipShapePaint2.setStrokeWidth(3/2*dm.density);
		focusedShipShapePaint2.setStyle(Style.STROKE);

		shipShapHighPaint = new Paint();
		shipShapHighPaint.setColor(view.getResources().getColor(R.color.red));
		shipShapHighPaint.setStrokeWidth(3/2*dm.density);
		shipShapHighPaint.setStyle(Style.FILL_AND_STROKE);

		paint_mid_point = new Paint();
		paint_mid_point.setStyle(Style.FILL_AND_STROKE);
		paint_mid_point.setAntiAlias(true);
		paint_mid_point.setColor(view.getResources().getColor(
				com.hifleet.R.color.blue));

		BitmapDrawable bd = (BitmapDrawable) view.getResources().getDrawable(
				R.drawable.icon_ships_test);
		mShipIcon = bd.getBitmap();
		
		shipbm1tt=getShipBitmap(1, true,true); shipbm0tt=getShipBitmap(0, true,true);
		shipbm1tf=getShipBitmap(1, true,false); shipbm0tf=getShipBitmap(0, true,false);
		shipbm1ff=getShipBitmap(1, false,false); shipbm0ff=getShipBitmap(0, false,false);
		
		if (timer == null) {
			timer = new Timer(true);
		}
		if (task == null) {
			task = new TimerTask() {
				public void run() {
					timerRefreshShipsData(tileBox);
				}
			};
			timer.schedule(task, 30*1000, 30*1000);
		}
//		if(shipbm1ff.getWidth()>shipbm1ff.getHeight()){
//		bwidth=shipbm1ff.getWidth();
//		}else{
//		bwidth=shipbm1ff.getHeight();
//		}
		// dm = new DisplayMetrics();
		// System.out.println("dm.density: "+dm.density);
		// System.out.println("view.dendity: "+view.getDensity());
		// getWindowManager().getDefaultDisplay().getMetrics(dm);
		lableadd = app.myPreferences.getBoolean("isShowMyTeamName", true);
	}

	private int basicLength = 12;
	private int exactLength;
	private float bmoffset = 0.5f;

	// 画一个填充色的船�?
	@SuppressLint("NewApi")
	private Bitmap getShipBitmap(double shipSp, boolean focused,
			boolean singletap) {
		exactLength = (int) dm.densityDpi * basicLength;
		// exactLength = (int)dm.densityDpi *basicLength;
		Bitmap shipbm;// = Bitmap.createBitmap(dm,
						// 14*(int)dm.density,38*(int)dm.density,
						// Bitmap.Config.ARGB_8888);

		Canvas can;// = new Canvas(shipbm);

		Path path = new Path();
		Path path1 = new Path();
		if (shipSp > 0) {
			// 画一个三角形带头
			if (singletap) {
				shipbm = Bitmap.createBitmap(dm, 26 * (int) dm.density,
						50 * (int) dm.density, Bitmap.Config.ARGB_8888);
				path1.moveTo(0 + bmoffset, 0 + bmoffset);
				path1.lineTo(0 + bmoffset, 6 * dm.density + bmoffset);
				path1.moveTo(0 + bmoffset, 0 + bmoffset);
				path1.lineTo(6 * dm.density + bmoffset, 0 + bmoffset);

				path1.moveTo(0 + bmoffset, 42 * dm.density + bmoffset);
				path1.lineTo(0 + bmoffset, 36 * dm.density + bmoffset);
				path1.moveTo(0 + bmoffset, 42 * dm.density + bmoffset);
				path1.lineTo(6 * dm.density + bmoffset, 42 * dm.density
						+ bmoffset);

				path1.moveTo(24 * dm.density + bmoffset, 0 + bmoffset);
				path1.lineTo(24 * dm.density + bmoffset, 6 * dm.density
						+ bmoffset);
				path1.moveTo(24 * dm.density + bmoffset, 0 + bmoffset);
				path1.lineTo(18 * dm.density + bmoffset, 0 + bmoffset);

				path1.moveTo(24 * dm.density + bmoffset, 42 * dm.density
						+ bmoffset);
				path1.lineTo(18 * dm.density + bmoffset, 42 * dm.density
						+ bmoffset);
				path1.moveTo(24 * dm.density + bmoffset, 42 * dm.density
						+ bmoffset);
				path1.lineTo(24 * dm.density + bmoffset, 36 * dm.density
						+ bmoffset);

				path.moveTo(6 + 2 * bmoffset, 6 + bmoffset);
				path.lineTo(18 * dm.density + 2 * bmoffset, 6 + bmoffset);
				path.lineTo(12 * dm.density + bmoffset, 30 * dm.density
						+ bmoffset);
				path.lineTo(6 + bmoffset, 6 + 2 * bmoffset);
				path.moveTo(12 * dm.density + 2 * bmoffset, 30 * dm.density
						+ bmoffset);
				path.lineTo(12 * dm.density + 2 * bmoffset, (24 + 18)
						* dm.density + bmoffset);
			} else {
				shipbm = Bitmap.createBitmap(dm, 14 * (int) dm.density,
						38 * (int) dm.density, Bitmap.Config.ARGB_8888);
				path.moveTo(0 + bmoffset, 0 + bmoffset);
				path.lineTo(12 * dm.density + bmoffset, 0 + bmoffset);
				path.lineTo(6 * dm.density + bmoffset, 24 * dm.density
						+ bmoffset);
				path.lineTo(0 + bmoffset, 0 + bmoffset);
				path.moveTo(6 * dm.density + bmoffset, 24 * dm.density
						+ bmoffset);
				path.lineTo(6 * dm.density + bmoffset, (24 + 12) * dm.density
						+ bmoffset);
			}
		} else {
			if (singletap) {
				shipbm = Bitmap.createBitmap(dm, 30 * (int) dm.density,
						30 * (int) dm.density, Bitmap.Config.ARGB_8888);
				path1.moveTo(0 + bmoffset, 0 + bmoffset);
				path1.lineTo(0 + bmoffset, 6 * dm.density + bmoffset);
				path1.moveTo(0 + bmoffset, 0 + bmoffset);
				path1.lineTo(6 * dm.density + bmoffset, 0 + bmoffset);

				path1.moveTo(0 + bmoffset, 28 * dm.density + bmoffset);
				path1.lineTo(0 + bmoffset, 22 * dm.density + bmoffset);
				path1.moveTo(0 + bmoffset, 28 * dm.density + bmoffset);
				path1.lineTo(6 * dm.density + bmoffset, 28 * dm.density
						+ bmoffset);

				path1.moveTo(28 * dm.density + bmoffset, 0 + bmoffset);
				path1.lineTo(28 * dm.density + bmoffset, 6 * dm.density
						+ bmoffset);
				path1.moveTo(28 * dm.density + bmoffset, 0 + bmoffset);
				path1.lineTo(22 * dm.density + bmoffset, 0 + bmoffset);

				path1.moveTo(28 * dm.density + bmoffset, 28 * dm.density
						+ bmoffset);
				path1.lineTo(22 * dm.density + bmoffset, 28 * dm.density
						+ bmoffset);
				path1.moveTo(28 * dm.density + bmoffset, 28 * dm.density
						+ bmoffset);
				path1.lineTo(28 * dm.density + bmoffset, 22 * dm.density
						+ bmoffset);

				path.moveTo(6 * dm.density + bmoffset, 14 * dm.density
						+ bmoffset);
				path.lineTo(14 * dm.density + bmoffset, 22 * dm.density
						+ bmoffset);
				path.lineTo(22 * dm.density + bmoffset, 14 * dm.density
						+ bmoffset);
				path.lineTo(14 * dm.density + bmoffset, 6 * dm.density
						+ bmoffset);
				path.lineTo(6 * dm.density + bmoffset, 14 * dm.density
						+ bmoffset);
			} else {
				// 画一个菱�?
				shipbm = Bitmap.createBitmap(dm, 18 * (int) dm.density,
						18 * (int) dm.density, Bitmap.Config.ARGB_8888);
				path.moveTo(0 + bmoffset, 8 * dm.density + bmoffset);
				path.lineTo(8 * dm.density + bmoffset, 16 * dm.density
						+ bmoffset);
				path.lineTo(16 * dm.density + bmoffset, 8 * dm.density
						+ bmoffset);
				path.lineTo(8 * dm.density + bmoffset, 0 * dm.density
						+ bmoffset);
				path.lineTo(0 * dm.density + bmoffset, 8 * dm.density
						+ bmoffset);
			}
		}
		can = new Canvas(shipbm);
		if (singletap) {
			can.drawPath(path1, focusedShipShapePaint2);
			can.drawPath(path, focusedShipShapePaint);
			can.drawPath(path, focusedShipShapePaint1);
		} else {
			if (!focused) {
				can.drawPath(path, shipShapPaint);
				can.drawPath(path, shipShapPaint1);
			} else {
				can.drawPath(path, focusedShipShapePaint);
				can.drawPath(path, focusedShipShapePaint1);
			}
		}
		return shipbm;
	}

	private Cell getCellIndex(double lon, double lat) {
		double _x = Math.floor((lon + 180) * 10);
		double _y = Math.floor((lat + 90) * 10);
		return new Cell(_x, _y);
	}

	public Canvas canvas;
	public static RotatedTileBox tileBox;
	private long lastCallAsynTaskTime = 0;
	private long lastCallTime = 0;
	private double callIntervalLimit = 0.5 * 1000L;
	private double callIntervalLimit1 = 1 * 1000L;
	private boolean teamflag = true;

	private boolean teamflag1 = true;

	public static void callbuffer() {
		// print("船舶层 call buffer");
		// view.callPrepareBufferImage("shipsInfoLayer", tileBox,false);
		addFleetVesselsInCurrentWindow(
				MyTeamShipsThread.currentLableshipsBeans, true);
	}

	public static void teamCallLable(ArrayList<ShipsBean> currentshipsBeans) {
		for (afterShip call : new ArrayList<afterShip>(c)) {
			call.shipRefresh(tileBox, currentshipsBeans);
		}
	}

	long predrawtime = 0;
	long nowdrawtime;

	@Override
	public void onDraw(Canvas canvas, RotatedTileBox tileBox,
			DrawSettings drawSettings) {

		this.tileBox = tileBox;
		this.canvas = canvas;

		// if (teamflag) {
		// if (app.myPreferences.getBoolean("isShowMyTeam", true)) {
		// print(" ondraw  isShowMyTeam");
		// MyTeamShipsThread thread = null;
		// thread = new MyTeamShipsThread();
		// thread.execute();
		// teamflag = false;
		// }
		// }
		// if (teamflag1) {
		// // System.out.println(" ondraw 刷新船队");
		// if (MyTeamShipsThread.shipsBeans.size() > 0) {
		// teamflag1 = false;
		// }
		// //refreshShipsInfoLayer2(canvas, tileBox);
		// //print("在船舶层ondraw函数中调用 callPrepareBufferImage");
		// view.callPrepareBufferImage("shipsInfoLayer", tileBox,false);
		// }
		// if (tileBox.getZoom() < START_SHOW) {
		// // print("当前比例尺小9，不再显示船舶信息了" + tileBox.getZoom());
		// _ships.clear();
		// return;
		// }

		// nowdrawtime = System.currentTimeMillis();
		//
		// if((nowdrawtime - predrawtime) >(1*500)){
		// predrawtime = nowdrawtime;
		// drawBaseMap();
		// refreshShipsInfoLayer(canvas, tileBox);
		// }else{
		// print("ondraw 调用太频繁了。");
		// }

	}

	private void timerRefreshShipsData(RotatedTileBox tileBox) {
		System.err.println("timer 刷新船舶数据");
		if (tileBox.getZoom() >= START_SHOW) {
			// 此时要刷新其他船舶
				allshipsrefresh = true;
				callShipInfoAction(tileBox);
				callHighLightedShipInfoAction(tileBox,"timer");//高亮船舶查询
				return;

		} 
//		else {
//
//			if (!isTheSameTileBox) {
//				closeReqest1();
//				if (app.myPreferences.getBoolean("IsLogin", false)) {
//				String uuid = UUID.randomUUID().toString();
//				MyTeamShipsThread thread = new MyTeamShipsThread();//加载船队船舶
//				teamntaskmap.put(uuid, thread);
//				if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
//					// print("MoreActivity 》 Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB");
//					thread.executeOnExecutor(Executors.newCachedThreadPool(),
//							new String[0]);
//				} else {
//					thread.execute();
//				}
//				}
//				return;
//			}
//		}
	}
	// 接收来到MapTileLayer发出的海图刷新结束的通知
	public void mapRefreshed(RotatedTileBox tileBox) {
		this.tileBox = tileBox;
//		if (!app.myPreferences.getBoolean("isShowdot", true)||
//				tileBox.getZoom() >= START_SHOW) {
//			print("收到刷图结束通知。");
			callDownloadShipsData(tileBox);
//		}
	}

	// long justCallTime = 0, thisCall = 0;
	private RotatedTileBox lastQueryTileBox = null;
	private boolean isTheSameTileBox = false;

	// 收到海图刷新结束，开始做以下几件事情：
	// 1.请求船舶数据（在适当的比例尺下，并且屏幕有移动，即屏幕的中心点前后发生了变化）
	// 2，刷新船舶。（在适当的比例尺下刷新交通流船舶，总是刷新船队船舶）
	private void callDownloadShipsData(RotatedTileBox tileBox) {
		// print("收到通知。"+tileBox.getZoom());
		// thisCall = System.currentTimeMillis();
		// long timeGap = thisCall - justCallTime;
		// print("timeGap： "+timeGap+(timeGap > (1 * 800L)));
		if (tileBox.getZoom() >= START_SHOW) {
			// 此时要刷新其他船舶
			if (lastQueryTileBox == null) {
				lastQueryTileBox = tileBox;
				isTheSameTileBox = false;
			} else {
				isTheSameTileBox = isTheSameTileBox(tileBox);
			}

			if (!isTheSameTileBox) {
				// 如果前后两次收到的刷新船舶时，屏幕范围不同，那么就发起请求最近一次的。
				// justCallTime = thisCall;
				// print("shipinfo call方法被调用请求");
				allshipsrefresh = true;
				callShipInfoAction(tileBox);
//				callHighLightedShipInfoAction(tileBox);//高亮船舶查询
				lastQueryTileBox = tileBox;
				return;
			}

			// print("时间间隔： "+(thisCall - justCallTime)
			// +", thisCall: "+thisCall+", justCall: "+justCallTime);

			// 如果前后收到两次通知的时间间隔比较短，就不做处理

			// if (timeGap > (1 * 200L)) {
			// print("超过时间间隔，调用view中的callPrepareBufferImage函数。");
			view.callPrepareBufferImage("shipsInfoLayer", tileBox, false);
			// justCallTime = thisCall;
			// }

		} else {

			if (lastQueryTileBox == null) {
				lastQueryTileBox = tileBox;
				isTheSameTileBox = false;
			} else {
				isTheSameTileBox = isTheSameTileBox(tileBox);
			}

			if (!isTheSameTileBox) {
				// 如果前后两次收到的刷新船舶时，屏幕范围不同，那么就发起请求最近一次的。
				// justCallTime = thisCall;
				// print("再次加载船舶");
				// refresh=true;
				// if(tileBox.getZoom()<6){
				// callbuffer();
				// lableadd=app.myPreferences.getBoolean("isShowMyTeamName",
				// true);
				// }else{
				closeReqest1();
				if (app.myPreferences.getBoolean("IsLogin", false)) {
				String uuid = UUID.randomUUID().toString();
				MyTeamShipsThread thread = new MyTeamShipsThread();//加载船队船舶
				teamntaskmap.put(uuid, thread);
				if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
					// print("MoreActivity 》 Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB");
					thread.executeOnExecutor(Executors.newCachedThreadPool(),
							new String[0]);
				} else {
					thread.execute();
				}
				}
				// }
				callHighLightedShipInfoAction(tileBox,"move");
				lastQueryTileBox = tileBox;
				return;
			}

			// if(timeGap > (1 * 200L)){
			// 这种情况下，当前比例尺比较小，还没有到该显示其他船舶的时候，那就只刷新船队中的船舶。

			// print("船舶层 else中调用veiw中的callPrepareBufferImage函数。");

			view.callPrepareBufferImage("shipsInfoLayer", tileBox, false);

			// justCallTime = thisCall;
			// }
		}
	}

	// 判断前后两次请求的屏幕范围是否是相同的。返回true就是相同的，返回false就是不同的。
	private boolean isTheSameTileBox(RotatedTileBox tileBox) {
		if (tileBox.getZoom() != lastQueryTileBox.getZoom()) {
			return false;
		}
		if (lastQueryTileBox != null) {
			LatLon lastLatLon = lastQueryTileBox.getCenterLatLon();
			LatLon thisLatLon = tileBox.getCenterLatLon();

			if ((lastLatLon.getLatitude() != thisLatLon.getLatitude())
					|| lastLatLon.getLongitude() != thisLatLon.getLongitude()) {
				return false;
			}
			return true;
		}
		return false;
	}

	@Override
	public void onPrepareBufferImage(Canvas canvas, RotatedTileBox tileBox,
			DrawSettings drawSettings) {
//		 print("刷船。");
		this.tileBox = tileBox;
		this.canvas = canvas;

		refreshShipsInfoLayer(canvas, tileBox);
	}

	public static void cleartapships() {
		tap_ships.clear();
		alltap_ships.clear();
	}

	// 触发点击
	@Override
	public boolean onSingleTap(PointF point, RotatedTileBox rtileBox) {
		if (rtileBox.getZoom() < START_SHOW) {
//			System.out.println("点击触发");
			List<ShipsBean> infoObjects = new ArrayList<ShipsBean>();
			getShipsInfo2(rtileBox, point, infoObjects);
			if (infoObjects != null) {
				for (ShipsBean fav : infoObjects) {
					Double la = Double.parseDouble(fav.la);
					Double lo = Double.parseDouble(fav.lo);
					AnimateDraggingMapThread thread = view
							.getAnimatedDraggingThread();
					// clearLayer();
					thread.startMoving(la, lo, rtileBox.getZoom(), false);

					int locationX = tileBox.getCenterPixelX();//
					int locationY = tileBox.getCenterPixelY();// fav);
					if (teamship.size() > 0) {
						for (int i1 = 0; i1 < teamship.size(); i1++) {
							boolean have = false;
							for (int i = 0; i < allteamship.size(); i++) {

								if (teamship.get(i1).m.equals(allteamship
										.get(i).m)) {
									allteamship.remove(i);
									allteamship.add(teamship.get(i1));
									have = true;
									break;
								}
							}
							if (!have) {
								allteamship.add(teamship.get(i1));
							}
						}
						teamship.clear();
					}
					if (searchshipsBeans.size() > 0) {
						for (int i1 = 0; i1 < searchshipsBeans.size(); i1++) {
							boolean have = false;
							for (int i = 0; i < allsearchshipsBeans.size(); i++) {

								if (searchshipsBeans.get(i1).m
										.equals(allsearchshipsBeans.get(i).m)) {
									allsearchshipsBeans.remove(i);
									allsearchshipsBeans.add(searchshipsBeans
											.get(i1));
									have = true;
									break;
								}
							}
							if (!have) {
								allsearchshipsBeans.add(searchshipsBeans
										.get(i1));
							}
						}
						searchshipsBeans.clear();
					}
					if (tap_ships.size() >= 1) {
						int have = 0;
						for (int at = 0; at < alltap_ships.size(); at++) {
							if (alltap_ships.get(at).m
									.equals(tap_ships.get(0).m)) {
								alltap_ships.remove(at);
								alltap_ships.add(tap_ships.get(0));
								tap_ships.clear();
								have++;
								break;
							}
						}
						if (have == 0) {
							alltap_ships.add(tap_ships.get(0));
							tap_ships.clear();
						}
					}
					tap_ships.add(fav);
					showPopupWindow(view, locationX, locationY, fav);
				}
				return true;
			}
		} else {
			List<ShipsBean> infoObjects = new ArrayList<ShipsBean>();
			getShipsInfo(rtileBox, point, infoObjects);
			if (!infoObjects.isEmpty()) {
				for (ShipsBean fav : infoObjects) {
					Double la = Double.parseDouble(fav.la);
					Double lo = Double.parseDouble(fav.lo);
					AnimateDraggingMapThread thread = view
							.getAnimatedDraggingThread();
					thread.startMoving(la, lo, rtileBox.getZoom(), false);
					int locationX = tileBox.getCenterPixelX();// tileBox.getPixXFromLonNoRot(lo);
					int locationY = tileBox.getCenterPixelY();//
					// tileBox.getPixYFromLatNoRot(la);
					if (teamship.size() > 0) {
						for (int i1 = 0; i1 < teamship.size(); i1++) {
							boolean have = false;
							for (int i = 0; i < allteamship.size(); i++) {

								if (teamship.get(i1).m.equals(allteamship
										.get(i).m)) {
									allteamship.remove(i);
									allteamship.add(teamship.get(i1));
									have = true;
									break;
								}
							}
							if (!have) {
								allteamship.add(teamship.get(i1));
							}
						}
						teamship.clear();
					}
					if (searchshipsBeans.size() > 0) {
						for (int i1 = 0; i1 < searchshipsBeans.size(); i1++) {
							boolean have = false;
							for (int i = 0; i < allsearchshipsBeans.size(); i++) {

								if (searchshipsBeans.get(i1).m
										.equals(allsearchshipsBeans.get(i).m)) {
									allsearchshipsBeans.remove(i);
									allsearchshipsBeans.add(searchshipsBeans
											.get(i1));
									have = true;
									break;
								}
							}
							if (!have) {
								allsearchshipsBeans.add(searchshipsBeans
										.get(i1));
							}
						}
						searchshipsBeans.clear();
					}
					teamship.clear();
					if (tap_ships.size() >= 1) {
						int have = 0;
						for (int at = 0; at < alltap_ships.size(); at++) {
							if (alltap_ships.get(at).m
									.equals(tap_ships.get(0).m)) {
								alltap_ships.remove(at);
								alltap_ships.add(tap_ships.get(0));
								tap_ships.clear();
								have++;
								break;
							}
						}
						if (have == 0) {
							alltap_ships.add(tap_ships.get(0));
							tap_ships.clear();
						}
					}
					tap_ships.add(fav);
					tap_shipsPoint.clear();
					System.err.println("tap_shipsPoint clear tap_shipsPoint clear tap_shipsPoint clear");
					tap_shipsPoint.add(fav);
					showPopupWindow(view, locationX, locationY, fav);
				}
				return true;
			}
		}

		return true;

	}

	private HashMap<String, LoadingShipsXMLThread> asyntaskmap = new HashMap<String, LoadingShipsXMLThread>();
	private HashMap<String, MyTeamShipsThread> teamntaskmap = new HashMap<String, MyTeamShipsThread>();
	private HashMap<String, LoadingHighlightedShipsXMLThread> hightaskmap = new HashMap<String, LoadingHighlightedShipsXMLThread>();

	public static boolean clearship = false;

	// public static boolean all=true;

	private void clearMapByUUID(String uuid) {
		asyntaskmap.remove(uuid);
	}

	private void closeReqest() {
		if (asyntaskmap.isEmpty())
			return;
		Iterator<String> it = asyntaskmap.keySet().iterator();
		while (it.hasNext()) {
			String uuid = it.next();
			LoadingShipsXMLThread task = asyntaskmap.get(uuid);
			task.cancel(true);
		}
	}

	private void closeReqest1() {
		if (teamntaskmap.isEmpty())
			return;
		Iterator<String> it = teamntaskmap.keySet().iterator();
		while (it.hasNext()) {
			String uuid = it.next();
			MyTeamShipsThread task = teamntaskmap.get(uuid);
			task.cancel(true);
		}
	}

	private void closehighReqest() {
		if (hightaskmap.isEmpty())
			return;
		Iterator<String> it = hightaskmap.keySet().iterator();
		while (it.hasNext()) {
			String uuid = it.next();
			LoadingHighlightedShipsXMLThread task = hightaskmap.get(uuid);
			task.cancel(true);
		}
	}
	
	private void callShipInfoAction(RotatedTileBox viewportToDraw) {
		closeReqest();
		String uuid = UUID.randomUUID().toString();
		LoadingShipsXMLThread task = new LoadingShipsXMLThread(uuid,
				viewportToDraw, canvas);
		asyntaskmap.put(uuid, task);
		// print("" + uuid + " 启动");
		execute(task);
	}
	
	private void callHighLightedShipInfoAction(RotatedTileBox viewportToDraw,String s) {
		closehighReqest();
		String uuid = UUID.randomUUID().toString();
		LoadingHighlightedShipsXMLThread task = new LoadingHighlightedShipsXMLThread(uuid,
				viewportToDraw, canvas,s);
		hightaskmap.put(uuid, task);
		// print("" + uuid + " 启动");
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
			task.executeOnExecutor(Executors.newCachedThreadPool(), new Void[0]);
		} else {
			task.execute(new Void[0]);
		}
	}

	// 判断android版本
	private void execute(LoadingShipsXMLThread task) {
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
			task.executeOnExecutor(Executors.newCachedThreadPool(), new Void[0]);
		} else {
			task.execute(new Void[0]);
		}
	}

	// 解析xml
	private void parseXMLnew(InputStream inStream) throws Exception {
		// System.out.println("解析xml");
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = factory.newDocumentBuilder();
		Document document = builder.parse(inStream);
		Element root = document.getDocumentElement();
		NodeList childNodes = root.getChildNodes();
		// System.out.println(document.toString());
		_ships.clear();
		// print("解析时ships"+_ships.size());

		// 判断是否超时
		if (root.getNodeName().compareTo("session_timeout") == 0) {
			heartBeatBean.add(XmlParseUtility.parse(root, HeartBeatBean.class));
			return;
		}

		// TODO 更新缓存部分
		// 船舶数据解析并加入_ships
		for (int j = 0; j < childNodes.getLength(); j++) {
			Node childNode = (Node) childNodes.item(j);
			if (childNode.getNodeType() == Node.ELEMENT_NODE) {
				Element childElement = (Element) childNode;
				if (childElement.getNodeName().compareTo("ship") == 0) {
					_ships.add(XmlParseUtility.parse(childElement,
							ShipsBean.class));
				}
			}
		}
		// System.out.println("_ships.size====" + _ships.size());
		// for(ShipsBean s:_ships){
		// System.out.println("_ships mmsi" +s.m);
		// }

		for (HeartBeatBean h : heartBeatBean) {
			// System.out.println("uuuuuuuuuuuu=" + h.message);
		}

		List<ShipsBean> myShips = new ArrayList<ShipsBean>();

		// System.out.println("_ships 长度�? "+_ships.size());

		myShips.addAll(_ships);
		_ships.clear();
		deleAllCurrentWindowCellShips();

		for (ShipsBean ship : myShips) {
			// System.out.println("MMSI: " + ship.m);
			// System.out.println("航向:" + "======" + ship.co);

			Cell c = getCellIndex(ship.getLo(), ship.getLa());// null

			if (_shipCellMap.containsKey(ship.getM())) {
				// 如果shipcellmap中包括该船舶的mmsi，先删除在该cell中船舶队列中该船舶的信息
				Cell ccell = _cellHashMap.get(_shipCellMap.get(ship.getM()));
				ccell.mmsiHashMapShipInfo().remove(ship.getM());
			}

			if (!_cellHashMap.containsKey(c.get_id())) {
				// 如果cellmap队列中没有这个cell，那么要把这个cell添加到cellmap进去�?
				// 同时把该船舶也添加到这个cell中船舶队列中去�??
				c.mmsiHashMapShipInfo().put(ship.getM(), ship);
				_cellHashMap.put(c.get_id(), c);
			} else {
				// cellmap中有这个cell了，那么要更新这个cell中船舶队列中该船舶的信息�?
				_cellHashMap.get(c.get_id()).mmsiHashMapShipInfo()
						.put(ship.getM(), ship);
			}

			// 更新ship-cell 索引
			_shipCellMap.put(ship.getM(), c.get_id());
		}
	}
	
	private void parseHships(InputStream inStream,String s) throws Exception {
		// System.out.println("解析xml");
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = factory.newDocumentBuilder();
		Document document = builder.parse(inStream);
		Element root = document.getDocumentElement();
		NodeList childNodes = root.getChildNodes();
		// System.out.println(document.toString());
		highlightedships.clear();
		// print("解析时ships"+_ships.size());

		// 判断是否超时
		if (root.getNodeName().compareTo("session_timeout") == 0) {
			heartBeatBean.add(XmlParseUtility.parse(root, HeartBeatBean.class));
			return;
		}

		// TODO 更新缓存部分
		// 船舶数据解析并加入_ships
		for (int j = 0; j < childNodes.getLength(); j++) {
			Node childNode = (Node) childNodes.item(j);
			if (childNode.getNodeType() == Node.ELEMENT_NODE) {
				Element childElement = (Element) childNode;
				if (childElement.getNodeName().compareTo("ship") == 0) {
					highlightedships.add(XmlParseUtility.parse(childElement,
							ShipsBean.class));
				}
			}
		}
		 System.out.println("highlightedships.size====" + highlightedships.size());
		// for(ShipsBean s:_ships){
		// System.out.println("_ships mmsi" +s.m);
		// }

		for (HeartBeatBean h : heartBeatBean) {
			// System.out.println("uuuuuuuuuuuu=" + h.message);
		}
        for(int i=0;i<highlightedships.size();i++){
        	for(int t=0;t<tap_ships.size();t++){
				if(tap_ships.get(t).getM().equals(highlightedships.get(i).getM())){
					tap_ships.set(t, highlightedships.get(i));
					if(s.equals("timer")){
						if(tap_shipsPoint.size()<=0){
							tap_shipsPoint.add(highlightedships.get(i));
							 print("tap_shipsPoint 0 size add"+tap_shipsPoint.size());
						}else if(!tap_shipsPoint.get(tap_shipsPoint.size()-1).ti
								.equals(highlightedships.get(i).ti)){
						tap_shipsPoint.add(highlightedships.get(i));
						 print("tap_shipsPoint add size"+tap_shipsPoint.size());
						}
						
						if(tap_shipsPoint.size()>=30){
							tap_shipsPoint.remove(0);
						}
					}
				}
			}
            for(int t=0;t<alltap_ships.size();t++){
            	if(alltap_ships.get(t).getM().equals(highlightedships.get(i).getM())){
            		alltap_ships.set(t, highlightedships.get(i));
				}
			}
            for(int t=0;t<searchshipsBeans.size();t++){
            	if(searchshipsBeans.get(t).getM().equals(highlightedships.get(i).getM())){
            		searchshipsBeans.set(t, highlightedships.get(i));
				}
			}
            for(int t=0;t<allsearchshipsBeans.size();t++){
            	if(allsearchshipsBeans.get(t).getM().equals(highlightedships.get(i).getM())){
            		allsearchshipsBeans.set(t, highlightedships.get(i));
				}
            }
            if(tileBox.getZoom()>START_SHOW){
            	 for(int t=0;t<MyTeamShipsThread.currentshipsBeans.size();t++){
            		 if(MyTeamShipsThread.currentshipsBeans.get(t).getM().equals(highlightedships.get(i).getM())){
            			 MyTeamShipsThread.currentshipsBeans.set(t, highlightedships.get(i));
     				}
 	            }	
            }
        }//更新高亮船舶。
		
	    }

	// 将当前窗口所有cells里面的船舶删�?
	private void deleAllCurrentWindowCellShips() {
		QuadRect rect = tileBox.getLatLonBounds();
		LatLon p3 = new LatLon(rect.top, rect.right);
		LatLon p1 = new LatLon(rect.bottom, rect.left);

		Cell blIndex = getCellIndex(p1.getLongitude(), p1.getLatitude());
		Cell trIndex = getCellIndex(p3.getLongitude(), p3.getLatitude());

		double rd = 0;

		for (double i = blIndex.get_x(); i <= trIndex.get_x() + rd; i++) {
			for (double j = blIndex.get_y(); j <= trIndex.get_y() + rd; j++) {
				String cellkey = "x" + i + "y" + j;
				if (_cellHashMap.containsKey(cellkey)) {
					(_cellHashMap.get(cellkey)).clearMMSIShipInfoMap();
				} else {
					continue;
				}
			}
		}
	}

	// 将属于当前窗口内的船舶加入到�?个显示队列中去�??
	private void addAllCellShips() {
		// System.out.println("调用 addAllCellShips");
		QuadRect rect = tileBox.getLatLonBounds();
		LatLon p3 = new LatLon(rect.top, rect.right);
		LatLon p1 = new LatLon(rect.bottom, rect.left);

		Cell blIndex = getCellIndex(p1.getLongitude(), p1.getLatitude());
		Cell trIndex = getCellIndex(p3.getLongitude(), p3.getLatitude());
		// System.out.println(blIndex.get_x()+" "+blIndex.get_y()+"----�?"+trIndex.get_x()+" "+trIndex.get_y()
		// +"lo"+p1.getLongitude()+" "+p3.getLongitude()+"la"+p1.getLatitude()+" "+p3.getLatitude());
		double rd = 0;

		int celling = 1000;

		// if (tileBox.getZoom() <= 11) {
		// celling = 4;
		// } else if (tileBox.getZoom() >= 12 && tileBox.getZoom() < 13) {
		// celling = 10;
		// } else if (tileBox.getZoom() >= 13) {
		// celling = 100;
		// }

		// int cellcount=0;
		// print("_ships2Draw准备添加"+_ships2Draw.size());
		for (double i = blIndex.get_x(); i <= trIndex.get_x() + rd; i++) {
			for (double j = blIndex.get_y(); j <= trIndex.get_y() + rd; j++) {
				String cellkey = "x" + i + "y" + j;
				// cellcount++;
				if (_cellHashMap.containsKey(cellkey)) {
					// print("cell添加船舶"+cellkey);
					addCellShipsLimited(_cellHashMap.get(cellkey), celling);

				}
			}
			// System.out.println("第一层for结束�?");
		}
		// print("cell数目："+cellcount);

	}

	private void addCellShipsLimited(Cell cell, int celling) {

		HashMap<String, ShipsBean> iMMSIHashMap = cell.mmsiHashMapShipInfo();
//		HashMap<String, ShipsBean> teamiMMSIHashMap = cell.mmsiTeamShipInfo();

		if (iMMSIHashMap != null) {

			try {
				int ceilingInner = celling > iMMSIHashMap.size() ? iMMSIHashMap
						.size() : celling;

				// print("ceilingInner: "+ceilingInner);

				String keysarray[] = (String[]) iMMSIHashMap.keySet().toArray(
						new String[0]); //
				// print("cell  contains"+keysarray.length);
				// String keysTarray[] = (String[])
				// iMMSIHashMap.keySet().toArray(
				// new String[0]);
				for (int i = 0; i < ceilingInner; i++) {
					String key = keysarray[i];
					// String Tkey = keysTarray[i];
					// if(keysTarray.length>1){
					// if(iMMSIHashMap.containsKey(Tkey)){
					// ShipsBean ship = iMMSIHashMap.get(Tkey);
					// Cell c=getCellIndex(ship.getLo(),ship.getLa());
					// System.out.println(key+"tkey 添加到了显示队列！： "+"length"+keysTarray.length+ship.getM()+"la"+ship.getLa()+"lo"+ship.getLo()
					// +"cx"+c.get_x()+"cy"+c.get_y());
					// _ships2Draw.add(ship);
					// }else{
					// ShipsBean ship = teamiMMSIHashMap.get(Tkey);
					// Cell c=getCellIndex(ship.getLo(),ship.getLa());
					// System.out.println(key+"tkey team添加到了显示队列！： "+ship.getM()+"la"+ship.getLa()+"lo"+ship.getLo()
					// +"cx"+c.get_x()+"cy"+c.get_y());
					// _ships2Draw.add(ship);
					// }
					// }else{
					ShipsBean ship = iMMSIHashMap.get(key);
					if (ship!=null&&!ship.equals(null)) {
						Cell c = getCellIndex(ship.getLo(), ship.getLa());
						// System.out.println(key+"添加到了显示队列！： "+ship.getM()+"la"+ship.getLa()+"lo"+ship.getLo()
						// +"cx"+c.get_x()+"cy"+c.get_y());
						_ships2Draw.add(ship);
					}
					// }// 加入过期的船队船舶
				}
			} catch (java.util.ConcurrentModificationException ex) {
				System.out.println("ConcurrentModificationException shipsinfo");
			} catch (Exception ex) {
				ex.printStackTrace();
			}

		}
		// System.out.println("待显示队列： "+_ships2Draw.size());
	}

	// public static void addFleetVesselsInCurrentWindow(ArrayList<ShipsBean>
	// showArray,
	// List<ShipsBean> shipsBeans,RotatedTileBox tileBox) {
	// // long startcount=System.currentTimeMillis();
	// // int justflag=0;
	// List<ShipsBean> shipsBeans1=new ArrayList<ShipsBean>();
	// shipsBeans1.addAll(shipsBeans);
	// if (shipsBeans1 != null && tileBox != null) {
	// LatLon lefttop = tileBox.getLeftTopLatLon();
	// LatLon rightbottom = tileBox.getRightBottomLatLon();
	//
	// double minlon = lefttop.getLongitude();
	// double maxlat = lefttop.getLatitude();
	// double maxlon = rightbottom.getLongitude();
	// double minlat = rightbottom.getLatitude();
	// showArray.clear();
	// // for (ShipsBean s : shipsBeans) {
	// //// justflag++;
	// // if (s.getLa() <= maxlat && s.getLa() >= minlat
	// // && s.getLo() >= minlon && s.getLo() <= maxlon) {
	// // showArray.add(s);
	// // }
	// // }
	// Iterator<ShipsBean> e = shipsBeans1.iterator();
	// print("计算当前屏幕内的船舶    所有船舶数量"+shipsBeans1.size());
	// try{
	// while(e.hasNext()){
	// ShipsBean element = e.next();
	// if (element.getLa() <= maxlat && element.getLa() >= minlat
	// && element.getLo() >= minlon && element.getLo() <= maxlon) {
	// showArray.add(element);
	// }
	// }
	// }catch (java.util.ConcurrentModificationException cme){
	// print("计算当前屏幕内的船舶"+cme);
	// showArray.addAll(MyTeamShipsThread.shipsBeans);
	// showArray.addAll(searchshipsBeans);
	// MyTeamShipsThread.currentshipsBeans.clear();
	// MyTeamShipsThread.currentshipsBeans.addAll(showArray);
	// print("计算当前屏幕内的船舶  qqq"+showArray.size());
	// if(refresh){
	// refresh=false;
	// view.callPrepareBufferImage("shipsInfoLayer", tileBox,true);
	// }
	// for(afterShip call :new ArrayList<afterShip>(c)){
	// call.shipRefresh(tileBox);
	// }
	// return;
	// }
	// // if (ShipsListAdapter.isMove) {
	// showArray.addAll(searchshipsBeans);
	// // }
	// MyTeamShipsThread.currentshipsBeans.clear();
	// MyTeamShipsThread.currentshipsBeans.addAll(showArray);
	// print("计算当前屏幕内的船舶"+showArray.size());
	// // for(int sa=0;sa<showArray.size();sa++){
	// // if(tap_ships.size()>=1){
	// // for(int i=0;i<tap_ships.size();i++){
	// // if(tap_ships.get(i).n.equals(showArray.get(sa).n)){
	// //
	// System.out.println("这是显示时存在的点击了的船舶"+tap_ships.get(i).n+showArray.size());
	// // }
	// // }
	// // }
	// // }
	// }
	// if(refresh){
	// refresh=false;
	// view.callPrepareBufferImage("shipsInfoLayer", tileBox,true);
	// }
	// // long endcount=System.currentTimeMillis();
	// // System.out.println("当前屏幕的船舶计算耗时"+(endcount-startcount)+"次数"+justflag);
	// for(afterShip call :new ArrayList<afterShip>(c)){
	// call.shipRefresh(tileBox);
	// }
	// }
	public static void addlableInCurrentWindow(String s) {
		caddedlable = new ArrayList<lableBean>();
//		 double minla =
//		 tileBox.getRightBottomLatLon().getLatitude();
//		 double maxlo =
//				 tileBox.getRightBottomLatLon().getLongitude();
//		 double maxla = tileBox.getLeftTopLatLon().getLatitude();
//		 double minlo = tileBox.getLeftTopLatLon().getLongitude();
//
//		 for (int i = 0; i <  ShipLableLayer.countclable.size(); i++) {
//		
//		 double sla = ShipLableLayer.countclable.get(i).lat;
//		 double slo = ShipLableLayer.countclable.get(i).lon;
//		
//		
//		 if (sla > minla && sla < maxla && slo > minlo && slo < maxlo) {
//			 caddedlable.add( ShipLableLayer.countclable.get(i));
//		 }
//		 }//计算当前屏幕内的 lable 未使用暂时注销掉
		caddedlable.addAll(ShipLableLayer.countclable);
		 print("执行了addlableInCurrentWindow  传入的列表长" + ShipLableLayer.countclable.size() + " hehe"
				 + caddedlable.size());
		
	}
	
	public static void addFleetVesselsInCurrentWindow(
			ArrayList<ShipsBean> showArray, boolean teamfresh) {
		ArrayList<ShipsBean> currentshipsBeans = new ArrayList<ShipsBean>();
		MyTeamShipsThread.currentshipsBeans.clear();
		if (tileBox.getZoom() > 6) {
			MyTeamShipsThread.addAllCellShips();
			// MyTeamShipsThread.addLableCellShips();
			// print("addFleetVesselsInCurrentWindow MyTeamShipsThread.currentshipsBeans"+MyTeamShipsThread.currentshipsBeans.size());
			currentshipsBeans.addAll(MyTeamShipsThread.currentshipsBeans);
		}
//		showArray.clear();
		// showArray.addAll(allteamship);
		// showArray.addAll(teamship);//不知道是否需要 添加 找到的船队船舶
		if (currentshipsBeans.size() > 0) {
			for (int s = 0; s < currentshipsBeans.size(); s++) {
				int c = 0;
				for (int cs = 0; cs < showArray.size(); cs++) {
					if (showArray.get(cs).m.equals(currentshipsBeans.get(s).m)) {
						c++;
						break;
					}
				}
				if (c == 0) {
					showArray.add(currentshipsBeans.get(s));
				}
			}//加入当前船队的船。
			
//			showArray.addAll(currentshipsBeans);
			print("计算当前屏幕的船队船舶" + currentshipsBeans.size() + "showarray"
					+ showArray.size());
			for (int s = 0; s < searchshipsBeans.size(); s++) {
				int c = 0;
				for (int cs = 0; cs < showArray.size(); cs++) {
					if (showArray.get(cs).m.equals(searchshipsBeans.get(s).m)) {
						c++;
						break;
					}
				}
				if (c == 0) {
					showArray.add(searchshipsBeans.get(s));
				}
			}
			// showArray.addAll(searchshipsBeans);// 搜索到的船舶
			for (int s = 0; s < allsearchshipsBeans.size(); s++) {
				int c = 0;
				for (int cs = 0; cs < showArray.size(); cs++) {
					if (showArray.get(cs).m
							.equals(allsearchshipsBeans.get(s).m)) {
						c++;
						break;
					}
				}
				if (c == 0) {
					showArray.add(allsearchshipsBeans.get(s));
				}
			}
			if (teamfresh) {
				// print("addFleetVesselsInCurrentWindow 准备通知lable");
				// refresh = false;
				ShipLableLayer.teamlable = true;
				if (lableadd) {
					// if(tileBox.getZoom()<6){
					// // view.callPrepareBufferImage("shipsInfoLayer",
					// tileBox,true);
					// }else{
					// view.callPrepareBufferImage("shipsInfoLayer",
					// tileBox,false);
					// }
				} else {
					// if((tileBox.getZoom()>=8&&tileBox.getZoom()<10)){
					// print("lableadd其实不是true。。。");
					view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
					// }else{
					// view.callPrepareBufferImage("shipsInfoLayer",
					// tileBox,false);
					// }
				}// 船队异步刷新
					// print("current teamCallLable"+currentshipsBeans.size()+"showarray"+showArray.size());
				teamCallLable(currentshipsBeans);
			}
			// 计算当前屏幕 比例尺较小情况下运算缓慢。 直接计算当前屏幕内船舶比较方便。
		} else if (MyTeamShipsThread.shipsBeans != null) {
			MyTeamShipsThread.currentshipsBeans.clear();
			double minla = tileBox.getRightBottomLatLon().getLatitude();
			double maxlo = tileBox.getRightBottomLatLon().getLongitude();
			double maxla = tileBox.getLeftTopLatLon().getLatitude();
			double minlo = tileBox.getLeftTopLatLon().getLongitude();

			for (int i = 0; i < MyTeamShipsThread.shipsBeans.size(); i++) {

				double sla = Double
						.valueOf(MyTeamShipsThread.shipsBeans.get(i).la);
				double slo = Double
						.valueOf(MyTeamShipsThread.shipsBeans.get(i).lo);

				if (sla > minla && sla < maxla && slo > minlo && slo < maxlo) {
					int c = 0;
					for (int cs = 0; cs < showArray.size(); cs++) {
						if (showArray.get(cs).m.equals(MyTeamShipsThread.shipsBeans.get(i).m)) {
							c++;
							break;
						}
					}
					if (c == 0) {
						showArray.add(MyTeamShipsThread.shipsBeans.get(i));
					}//显示加入船队的船
//					showArray.add(MyTeamShipsThread.shipsBeans.get(i));
					MyTeamShipsThread.currentshipsBeans.add(MyTeamShipsThread.shipsBeans.get(i));
				}
			}
			for (int s = 0; s < searchshipsBeans.size(); s++) {
				int c = 0;
				for (int cs = 0; cs < showArray.size(); cs++) {
					if (showArray.get(cs).m.equals(searchshipsBeans.get(s).m)) {
						c++;
						break;
					}
				}
				if (c == 0) {
					showArray.add(searchshipsBeans.get(s));
				}
			}
			// showArray.addAll(searchshipsBeans);// 搜索到的船舶
			for (int s = 0; s < allsearchshipsBeans.size(); s++) {
				int c = 0;
				for (int cs = 0; cs < showArray.size(); cs++) {
					if (showArray.get(cs).m
							.equals(allsearchshipsBeans.get(s).m)) {
						c++;
						break;
					}
				}
				if (c == 0) {
					showArray.add(allsearchshipsBeans.get(s));
				}
			}
			// showArray.addAll(allsearchshipsBeans);
			// print("执行了all setlable  传入的列表长" + teamShipsBeans.size() +
			// "  "+teamShipsBeans2.size());

			// all=true;
			// print("直接添加所有的船队船舶"+currentshipsBeans.size()+"showarray"+showArray.size());
			// showArray.addAll(MyTeamShipsThread.shipsBeans);
			if (teamfresh) {
				// refresh=false;
				ShipLableLayer.teamlable = true;
				if (lableadd) {
//					view.callPrepareBufferImage("shipsInfoLayer", tileBox,
//							false);
				} else {
					// if(tileBox.getZoom()>=8&&tileBox.getZoom()<10){
					view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
					// }else{
					// view.callPrepareBufferImage("shipsInfoLayer",
					// tileBox,false);
					// }
				}// 船队异步刷新

				// print("all teamCallLable"+MyTeamShipsThread.shipsBeans.size()+"showarray"+showArray.size());
				for (afterShip call : new ArrayList<afterShip>(c)) {
					call.shipRefresh(tileBox, MyTeamShipsThread.shipsBeans);
				}
			}

		}
		// print("退出   addfleet");
	}

	public static void clearLayer() {
		clearship = true;
		view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
	}

	public void showSearchships() {
		if (TeamShipsListAdapter.isMove && teamship != null
				&& teamship.size() >= 1) {
			// print("进入   moveteam");
			// TeamShipsListAdapter.isMove = false;
			// view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
			// if(teamship.size()>0){
			int have = 0;
			for (int i = 0; i < MyTeamShipsThread.shipsBeans.size(); i++) {
				if (teamship.get(0).getM()
						.equals(MyTeamShipsThread.shipsBeans.get(i).getM())) {
					teamship.remove(0);
					teamship.add(MyTeamShipsThread.shipsBeans.get(i));
					have++;
					break;
				}
				if (have == 0) {
					MyTeamShipsThread.shipsBeans.add(teamship.get(0));
				}
			}// 列表查看的船队的船 可能在shipsBeans存在也可能不存在。 存在的使用allfleetships替换
			Double la = null, lo = null;
			la = Double.parseDouble(teamship.get(0).la);
			lo = Double.parseDouble(teamship.get(0).lo);
			thread.startMoving(la, lo, tileBox.getZoom(), false);
			// view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
			int locationX1 = tileBox.getCenterPixelX();// tileBox.getPixXFromLonNoRot(fav.getLo());
			int locationY1 = tileBox.getCenterPixelY();// fav);
			showPopupWindow(view, locationX1, locationY1, teamship.get(0));
//			ShipLableLayer.clearLayer();
			ShipLableLayer.teamlable = true;
			view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
			TeamShipsListAdapter.isMove = false;
		}
//		if (app.myPreferences.getBoolean("IsLogin", false)) {
			if (ShipsListAdapter.isMove && searchshipsBeans != null
					&& searchshipsBeans.size() >= 1) {

				// view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
				// if(){
				Double la = null, lo = null;
				la = Double.parseDouble(searchshipsBeans.get(searchshipsBeans
						.size() - 1).la);
				lo = Double.parseDouble(searchshipsBeans.get(searchshipsBeans
						.size() - 1).lo);
				thread.startMoving(la, lo, tileBox.getZoom(), false);
				// view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
				int locationX1 = tileBox.getCenterPixelX();// tileBox.getPixXFromLonNoRot(fav.getLo());
				int locationY1 = tileBox.getCenterPixelY();// fav);

				showPopupWindow(view, locationX1, locationY1,
						searchshipsBeans.get(searchshipsBeans.size() - 1));
//				ShipLableLayer.clearLayer();
				ShipLableLayer.teamlable = true;
				view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
				ShipsListAdapter.isMove = false;
			}
//		}
	}

	private void refreshShipsInfoLayer(Canvas canvas, RotatedTileBox tileBox) {
		 print("刷新船舶   ");
		ArrayList<ShipsBean> showArray = new ArrayList<ShipsBean>();
		if (tileBox.getZoom() >= START_SHOW) {
			// 如果缩放比例尺到了该显示其他船舶的层级，那就把当前窗口范围内的船舶加入到待显示队列中。
			_ships2Draw = new ArrayList<ShipsBean>();
			addAllCellShips();
			// if (ShipsListAdapter.isMove) {
			// _ships2Draw.addAll(searchshipsBeans);
			// }
			showArray.addAll(_ships2Draw);
			
			addFleetVesselsInCurrentWindow(showArray, false);//加入船队的船，和搜索到的船舶。
			
			// showArray.addAll(teamship);
			// showArray.addAll(allsearchshipsBeans);
			// showArray.addAll(searchshipsBeans);
			if (allshipsrefresh) {
				allshipsrefresh = false;
				if (_ships2Draw.size() > 0) {
					// all=false;
					teamCallLable(_ships2Draw);
				}

			}
			// _ships2Draw.clear();
			// print("刷新船舶" +
			// showArray.size()+"zoom"+tileBox.getZoom()+"_ships2Draw"+_ships2Draw.size());
		} else {
			if (MyTeamShipsThread.shipsBeans != null
					&& !app.myPreferences.getBoolean("IsLogin", false)) {
				MyTeamShipsThread.shipsBeans.clear();
				MyTeamShipsThread.deleAllCurrentCellShips();
			}
			if(app.myPreferences.getBoolean("IsLogin", false)){
			addFleetVesselsInCurrentWindow(showArray, false);
			}else{
				caddedlable.clear();
				for (int s = 0; s < searchshipsBeans.size(); s++) {
					int c = 0;
					for (int cs = 0; cs < showArray.size(); cs++) {
						if (showArray.get(cs).m.equals(searchshipsBeans.get(s).m)) {
							c++;
							break;
						}
					}
					if (c == 0) {
						showArray.add(searchshipsBeans.get(s));
					}
				}
				// showArray.addAll(searchshipsBeans);// 搜索到的船舶
				for (int s = 0; s < allsearchshipsBeans.size(); s++) {
					int c = 0;
					for (int cs = 0; cs < showArray.size(); cs++) {
						if (showArray.get(cs).m
								.equals(allsearchshipsBeans.get(s).m)) {
							c++;
							break;
						}
					}
					if (c == 0) {
						showArray.add(allsearchshipsBeans.get(s));
					}
				}
			}
			// print("刷新船舶" + searchshipsBeans.size()+"zoom"+tileBox.getZoom());
			// showArray.addAll(MyTeamShipsThread.currentshipsBeans);
			for (int i = 0; i < alltap_ships.size(); i++) {
				// print("进入比较循环1");
				boolean alltap_shipshave = false;
				for (int j = 0; j < showArray.size(); j++) {
					if (alltap_ships.get(i).m.equals(showArray.get(j).m)) {
						// System.out.println("比例尺较小全部点击的无船队船舶");
						alltap_shipshave = true;
						break;
					}
				}
				if (!alltap_shipshave) {
					showArray.add(alltap_ships.get(i));
					// print("增加所有点击船舶" + showArray.size());
				}
			}
			if (tap_ships.size() >= 1) {
				boolean tap_shipshave = false;
			for (int j = 0; j < showArray.size(); j++) {
				// print("进入比较循环2"+tap_ships.size());
//				if (tap_ships.size() >= 1) {
					// print("tap_ships不是空");
					if (showArray.get(j).m.equals(tap_ships.get(0).m)) {
						// System.out.println("比例尺较小加入点击的无船队船舶");
						tap_shipshave = true;
						break;
					}

//				}
				// print("结束比较循环2");
			}
			if(!tap_shipshave){
				showArray.add(tap_ships.get(0));
			}
			}
			// print("船舶加载完毕" + showArray.size());
		}
		// 将属于当前窗口范围内的船队船舶加入到待显示队列。
		// addFleetVesselsInCurrentWindow(showArray,
		// MyTeamShipsThread.shipsBeans,
		// tileBox);
		// print("画之前的_ships2Draw size: " + showArray.size());
		// if(clearship){
		// showArray.clear();
		// clearship=false;
		// print("清空一次船舶");
		// }
		// print("准备draw船舶" + showArray.size());
		focusedships = new ArrayList<ShipsBean>();
		if(tileBox.getZoom() >= START_SHOW){
		for (ShipsBean obj : showArray) {
			// print("showArray"+showArray.size());
			if (obj == null) {
				print("obj null.");
				return;
			}
			int have1 = 0;//判断是否红色
			for (int tap = 0; tap < alltap_ships.size(); tap++) {
				if (alltap_ships.get(tap).m.equals(obj.m)) {
					have1++;
					focusedships.add(obj);
					break;
				}
			}
			if (MyTeamShipsThread.shipsBeans != null&&have1==0) {
				for (int tap = 0; tap < MyTeamShipsThread.shipsBeans.size(); tap++) {
					if (MyTeamShipsThread.shipsBeans.get(tap).m.equals(obj.m)) {
						have1++;
						focusedships.add(obj);
						break;
						// print("这是船队的船");
					}
				}
			}
			// for (int tap = 0; tap < allteamship.size(); tap++) {
			// if (allteamship.get(tap).m.equals(obj.m)) {
			// have1++;
			// }
			// }//如果移动海图获取的是所有船队船舶就不需要了。
			if(have1==0){
			for (int tap = 0; tap < allsearchshipsBeans.size(); tap++) {
				if (allsearchshipsBeans.get(tap).m.equals(obj.m)) {
					have1++;
					focusedships.add(obj);
					break;
				}
			}
			}
			
			int have = 0;//判断是否被选中
			for (int tap = 0; tap < tap_ships.size(); tap++) {
				if (tap_ships.get(tap).m.equals(obj.m)) {
					have++;
					focusedships.add(obj);
					break;
				}
			}
			if(have==0){
			for (int tap = 0; tap < searchshipsBeans.size(); tap++) {
				if (searchshipsBeans.get(tap).m.equals(obj.m)) {
					have++;
					focusedships.add(obj);
					break;
				}
			}
			}
			if(have==0){
			for (int tap = 0; tap < teamship.size(); tap++) {
				if (teamship.get(tap).m.equals(obj.m)) {
					have++;
					focusedships.add(obj);
					break;
				}
			}
			}
			shipbm1=null;
			shipbm0=null;
			if (have == 0) {
				if (have1 == 0) {
					shipbm1 = shipbm1ff;
					shipbm0 = shipbm0ff;
				} else {
					shipbm1 =shipbm1tf;
					shipbm0 =shipbm0tf;
				}
			} else {
				// print("点击的 fleet: "+obj.n+"角度"+obj.co+"size"+showArray.size());
				shipbm1 =shipbm1tt;
				shipbm0 =shipbm0tt;
			}
			// print("fleet: "+obj.dn);

			int locationX = tileBox.getPixXFromLonNoRot(obj.getLo());
			int locationY = tileBox.getPixYFromLatNoRot(obj.getLa());

			try {
				canvas.save();
				if (shipbm1 != null && shipbm0 != null) {
					if (have == 0) {
						if (obj.getSp() > 0) {
							canvas.rotate(obj.getCo() + 180, locationX,
									locationY);
							canvas.drawBitmap(shipbm1,
									locationX - shipbm1.getWidth() / 2,
									locationY - shipbm1.getHeight() / 2 + 12
											* dm.density, shipShapPaint);
						} else {
							canvas.drawBitmap(shipbm0,
									locationX - shipbm0.getWidth() / 2 + 2
											* bmoffset,
									locationY - shipbm0.getHeight() / 2 + 2
											* bmoffset, shipShapPaint);
							canvas.drawCircle(locationX, locationY, 2,
									locationPaint);
						}
					} else {
						// System.out.println("这是点击后的船"+obj.n+obj.co);
						if (obj.getSp() > 0) {
							canvas.rotate(obj.getCo() + 180, locationX,
									locationY);
							canvas.drawBitmap(shipbm1,
									locationX - shipbm1.getWidth() / 2,
									locationY - shipbm1.getHeight() / 2 + 12
											* dm.density, shipShapPaint);
						} else {
							canvas.drawBitmap(shipbm0,
									locationX - shipbm0.getWidth() / 2 + 2
											* bmoffset,
									locationY - shipbm0.getHeight() / 2 + 2
											* bmoffset, shipShapPaint);
							canvas.drawCircle(locationX, locationY, 2,
									locationPaint);
						}
					}
				}
				canvas.restore();
			} catch (Exception ex) {
				ex.printStackTrace();
			}
		}
		}else{
			focusedships.addAll(showArray);
		}
		for (ShipsBean obj : focusedships) {
			// print("showArray"+showArray.size());
			if (obj == null) {
				print("obj null.");
				return;
			}
			int have1 = 0;//判断是否红色
			for (int tap = 0; tap < alltap_ships.size(); tap++) {
				if (alltap_ships.get(tap).m.equals(obj.m)) {
					have1++;
					break;
				}
			}
			if (MyTeamShipsThread.shipsBeans != null&&have1==0) {
				for (int tap = 0; tap < MyTeamShipsThread.shipsBeans.size(); tap++) {
					if (MyTeamShipsThread.shipsBeans.get(tap).m.equals(obj.m)) {
						have1++;
						break;
						// print("这是船队的船");
					}
				}
			}
			// for (int tap = 0; tap < allteamship.size(); tap++) {
			// if (allteamship.get(tap).m.equals(obj.m)) {
			// have1++;
			// }
			// }//如果移动海图获取的是所有船队船舶就不需要了。
			if(have1==0){
			for (int tap = 0; tap < allsearchshipsBeans.size(); tap++) {
				if (allsearchshipsBeans.get(tap).m.equals(obj.m)) {
					have1++;
					break;
				}
			}
			}
			
			int have = 0;//判断是否被选中
			for (int tap = 0; tap < tap_ships.size(); tap++) {
				if (tap_ships.get(tap).m.equals(obj.m)) {
					have++;
					break;
				}
			}
			if(have==0){
			for (int tap = 0; tap < searchshipsBeans.size(); tap++) {
				if (searchshipsBeans.get(tap).m.equals(obj.m)) {
					have++;
					break;
				}
			}
			}
			if(have==0){
			for (int tap = 0; tap < teamship.size(); tap++) {
				if (teamship.get(tap).m.equals(obj.m)) {
					have++;
					break;
				}
			}
			}
			if (have == 0) {
				if (have1 == 0) {
					shipbm1 = shipbm1ff;
					shipbm0 = shipbm0ff;
				} else {
					shipbm1 =shipbm1tf;
					shipbm0 =shipbm0tf;
				}
			} else {
				// print("点击的 fleet: "+obj.n+"角度"+obj.co+"size"+showArray.size());
				shipbm1 =shipbm1tt;
				shipbm0 =shipbm0tt;
			}
			// print("fleet: "+obj.dn);

			int locationX = tileBox.getPixXFromLonNoRot(obj.getLo());
			int locationY = tileBox.getPixYFromLatNoRot(obj.getLa());

			try {
				canvas.save();
				if (shipbm1 != null && shipbm0 != null) {
					if (have == 0) {
						if (obj.getSp() > 0) {
							canvas.rotate(obj.getCo() + 180, locationX,
									locationY);
							canvas.drawBitmap(shipbm1,
									locationX - shipbm1.getWidth() / 2,
									locationY - shipbm1.getHeight() / 2 + 12
											* dm.density, shipShapPaint);
						} else {
							canvas.drawBitmap(shipbm0,
									locationX - shipbm0.getWidth() / 2 + 2
											* bmoffset,
									locationY - shipbm0.getHeight() / 2 + 2
											* bmoffset, shipShapPaint);
							canvas.drawCircle(locationX, locationY, 2,
									locationPaint);
						}
					} else {
						// System.out.println("这是点击后的船"+obj.n+obj.co);
						if (obj.getSp() > 0) {
							canvas.rotate(obj.getCo() + 180, locationX,
									locationY);
							canvas.drawBitmap(shipbm1,
									locationX - shipbm1.getWidth() / 2,
									locationY - shipbm1.getHeight() / 2 + 12
											* dm.density, shipShapPaint);
						} else {
							canvas.drawBitmap(shipbm0,
									locationX - shipbm0.getWidth() / 2 + 2
											* bmoffset,
									locationY - shipbm0.getHeight() / 2 + 2
											* bmoffset, shipShapPaint);
							canvas.drawCircle(locationX, locationY, 2,
									locationPaint);
						}
					}
				}
				canvas.restore();
			} catch (Exception ex) {
				ex.printStackTrace();
			}

		}
		for (ShipsBean obj : tap_shipsPoint) {
//			print("zhixingyici tap_shipsPoint"+tap_shipsPoint.size());
			if (obj == null) {
				return;
			}
			print("tap_shipsPoint la"+obj.getLa()+" lo:"+obj.getLo()+
					"tap_ships la"+tap_ships.get(0).getLa()+"tap_ships lo"+tap_ships.get(0).getLo()
					+"size::"+tap_shipsPoint.size());
			if(obj.getLa()==tap_ships.get(0).getLa()
							&&obj.getLo()==tap_ships.get(0).getLo()){
			continue;
			}
			
			int locationX = tileBox.getPixXFromLonNoRot(obj.getLo());
			int locationY = tileBox.getPixYFromLatNoRot(obj.getLa());

			try {
				canvas.save();
				canvas.drawCircle(locationX, locationY, 5,
						locationPaint);
				canvas.restore();
			} catch (Exception ex) {
				ex.printStackTrace();
			}

		}
		showArray.clear();
		focusedships.clear();
		// flag = true;
		// System.out.println("画完chuanbo");
		// System.out.println("ships1 size清空�?: " + _ships1.size());
		// if (TeamShipsListAdapter.isMove) {
		// // print("进入   moveteam");
		// // TeamShipsListAdapter.isMove = false;
		// // view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
		// // if(teamship.size()>0){
		// Double la = null, lo = null;
		// la = Double.parseDouble(teamship.get(0).la);
		// lo = Double.parseDouble(teamship.get(0).lo);
		// thread.startMoving(la, lo, tileBox.getZoom(), false);
		// // view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
		// int locationX1 = tileBox.getCenterPixelX();//
		// tileBox.getPixXFromLonNoRot(fav.getLo());
		// int locationY1 = tileBox.getCenterPixelY();// fav);
		// showPopupWindow(view, locationX1, locationY1, teamship.get(0));
		// // ShipLableLayer.teamlable=true;
		// // view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
		// // }
		// TeamShipsListAdapter.isMove = false;
		// }
		// if (ShipsListAdapter.isMove) {
		//
		// // view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
		// //if(){
		// Double la = null, lo = null;
		// la = Double.parseDouble(searchshipsBeans
		// .get(searchshipsBeans.size() - 1).la);
		// lo = Double.parseDouble(searchshipsBeans
		// .get(searchshipsBeans.size() - 1).lo);
		// thread.startMoving(la, lo, tileBox.getZoom(), false);
		// // view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
		// int locationX1 = tileBox.getCenterPixelX();//
		// tileBox.getPixXFromLonNoRot(fav.getLo());
		// int locationY1 = tileBox.getCenterPixelY();// fav);
		//
		// showPopupWindow(view, locationX1, locationY1,
		// searchshipsBeans.get(searchshipsBeans
		// .size() - 1));
		// // ShipLableLayer.teamlable=true;
		// // view.callPrepareBufferImage("shipsInfoLayer", tileBox, true);
		// ShipsListAdapter.isMove = false;
		// //}
		// }

	}

	class LoadingShipsXMLThread extends AsyncTask<Void, String, String> {
		String uuid;
		private RotatedTileBox privateTileBox;
		private Canvas privateCanvas;

		public LoadingShipsXMLThread(String uuid, RotatedTileBox box,
				Canvas canvas) {
			this.uuid = uuid;
			this.privateTileBox = box;
			this.privateCanvas = canvas;
			// System.out.println("LoadingShipsXMLThread");
			// refreshShipsInfoLayer(privateCanvas, privateTileBox);
		}

		protected void onPreExecute() {

		}

		protected void onProgressUpdate(String... values) {

		}

		protected void updateProgress(boolean updateOnlyProgress) {

		}

		protected void onPostExecute(String result) {
			// print("船舶层异步结束。view . shipInfoLayer请求: "+uuid);
			clearMapByUUID(uuid);
			allshipsrefresh = true;
			ShipLableLayer.teamlable = true;
			view.callPrepareBufferImage("shipsInfoLayer", privateTileBox, true);
			// 刷新数据
			// refreshShipsInfoLayer(privateCanvas, privateTileBox);
			// if(canvas!=null&&!canvas.equals(null)){
			// Paint paint = new Paint(); //设置�?个笔刷大小是3的黄色的画笔
			// paint.setColor(Color.blue);
			// paint.setStrokeJoin(Paint.Join.ROUND);
			// paint.setStrokeCap(Paint.Cap.ROUND);
			// paint.setStrokeWidth(3);
			// canvas.drawCircle(100, 100, 90, paint);
			// }
			// System.out.println("主线程里面的onPostExecute");

			// refreshShipsInfoLayer(privateCanvas, privateTileBox);
		}

		protected void onCancelled() {
			// print("" + uuid + " cancelled.");
		}

		HttpURLConnection conn;

		@Override
		protected String doInBackground(Void... arg0) {
			// flag = false;
			try {
				if (this.isCancelled()) {
					// print("线程取消 1.");
					return null;
				}
				QuadRect rect = privateTileBox.getLatLonBounds();
				LatLon p3 = new LatLon(rect.top, rect.right);
				LatLon p2 = new LatLon(rect.top, rect.left);
				LatLon p1 = new LatLon(rect.bottom, rect.left);
				LatLon p4 = new LatLon(rect.bottom, rect.right);
				String polygon = "Polygon((" + p2.getLongitude() + "%20"
						+ p2.getLatitude() + "," + p1.getLongitude() + "%20"
						+ p1.getLatitude() + "," + p4.getLongitude() + "%20"
						+ p4.getLatitude() + "," + p3.getLongitude() + "%20"
						+ p3.getLatitude() + "," + p2.getLongitude() + "%20"
						+ p2.getLatitude() + "))";
				String bboxurl = app.myPreferences.getString("loginserver",
						null) + IndexConstants.GET_BBOX_SHIPS_URL + polygon;

				// System.out.println("URL" + "====" + bboxurl);

				URL url = new URL(bboxurl);

				if (this.isCancelled()) {
					// print("线程取消 2 .");
					return null;
				}

				conn = (HttpURLConnection) url.openConnection();
				if (loginSession.getSessionid() != null) {
					conn.setRequestProperty("cookie",
							loginSession.getSessionid());
				} else {
					conn.setRequestProperty("cookie",
							app.myPreferences.getString("sessionid", ""));
				}
				// System.out.println("ships sessionid" + "===="
				// +app.myPreferences.getString("sessionid", ""));
				conn.setConnectTimeout(10000);

				InputStream inStream = conn.getInputStream();

				if (this.isCancelled()) {
					// print("线程取消 3.");
					inStream.close();
					return null;
				}

				parseXMLnew(inStream);
				inStream.close();
				// print(uuid+" 获得数据。");
				// flag = true;
			} catch (Exception ex) {
				ex.printStackTrace();
			}
			return null;
		}
	}

	class LoadingHighlightedShipsXMLThread extends AsyncTask<Void, String, String> {
		String uuid;
		String s;
		private RotatedTileBox privateTileBox;
		private Canvas privateCanvas;

		public LoadingHighlightedShipsXMLThread(String uuid, RotatedTileBox box,
				Canvas canvas,String s) {
			this.uuid = uuid;
			this.privateTileBox = box;
			this.privateCanvas = canvas;
			this.s=s;
			// System.out.println("LoadingShipsXMLThread");
			// refreshShipsInfoLayer(privateCanvas, privateTileBox);
		}

		protected void onPreExecute() {

		}

		protected void onProgressUpdate(String... values) {

		}

		protected void updateProgress(boolean updateOnlyProgress) {

		}

		protected void onPostExecute(String result) {
			// print("船舶层异步结束。view . shipInfoLayer请求: "+uuid);
//			allshipsrefresh = true;
//			ShipLableLayer.teamlable = true;
//			view.callPrepareBufferImage("shipsInfoLayer", privateTileBox, true);
		}

		protected void onCancelled() {
			// print("" + uuid + " cancelled.");
		}

		HttpURLConnection conn;

		@Override
		protected String doInBackground(Void... arg0) {
			// flag = false;
			try {
				if (this.isCancelled()) {
					// print("线程取消 1.");
					return null;
				}
//				QuadRect rect = privateTileBox.getLatLonBounds();
//				LatLon p3 = new LatLon(rect.top, rect.right);
//				LatLon p2 = new LatLon(rect.top, rect.left);
//				LatLon p1 = new LatLon(rect.bottom, rect.left);
//				LatLon p4 = new LatLon(rect.bottom, rect.right);
//				String polygon = "Polygon((" + p2.getLongitude() + "%20"
//						+ p2.getLatitude() + "," + p1.getLongitude() + "%20"
//						+ p1.getLatitude() + "," + p4.getLongitude() + "%20"
//						+ p4.getLatitude() + "," + p3.getLongitude() + "%20"
//						+ p3.getLatitude() + "," + p2.getLongitude() + "%20"
//						+ p2.getLatitude() + "))";
				String mmsis="";
				String ormmsiString = new String("'or mmsi='".getBytes("UTF-8"));
				String ormmsi = URLEncoder.encode(ormmsiString, "UTF-8");
//				String ormmsi
//				= URLEncoder.encode("'or mmsi='", "UTF-8");
				for(int t=0;t<tap_ships.size();t++){
					if(mmsis.equals("")){
						mmsis=tap_ships.get(t).getM();
					}else{
					mmsis=mmsis+ormmsi+tap_ships.get(t).getM();
					}
				}
                for(int t=0;t<alltap_ships.size();t++){
                	if(mmsis.equals("")){
						mmsis=alltap_ships.get(t).getM();
					}else{
					mmsis=mmsis+ormmsi+alltap_ships.get(t).getM();
					}
				}
                for(int t=0;t<searchshipsBeans.size();t++){
                	if(mmsis.equals("")){
						mmsis=searchshipsBeans.get(t).getM();
					}else{
					mmsis=mmsis+ormmsi+searchshipsBeans.get(t).getM();
					}
				}
                for(int t=0;t<allsearchshipsBeans.size();t++){
                	if(mmsis.equals("")){
						mmsis=allsearchshipsBeans.get(t).getM();
					}else{
					mmsis=mmsis+ormmsi+allsearchshipsBeans.get(t).getM();
					}
	            }
                if(tileBox.getZoom()>=START_SHOW){
                	 for(int t=0;t<MyTeamShipsThread.currentshipsBeans.size();t++){
                		 if(mmsis.equals("")){
     						mmsis=MyTeamShipsThread.currentshipsBeans.get(t).getM();
     					}else{
     					mmsis=mmsis+ormmsi+MyTeamShipsThread.currentshipsBeans.get(t).getM();
     					}	
     	            }	
                }
                if(mmsis.equals("")){
//                	System.err.println("mmsis ==null"+MyTeamShipsThread.currentshipsBeans.size());
                	return "";}
				String highshipsurl = app.myPreferences.getString("loginserver",
						null) + IndexConstants.GET_HIGHlIGHTED_SHIPS_URL + mmsis;
//				String highshipsurl= URLEncoder.encode(hurl, "UTF-8");
				 System.out.println("HighlightedShipsURL" + "====" + highshipsurl+"  s::"+s);

				URL url = new URL(highshipsurl);

				if (this.isCancelled()) {
					// print("线程取消 2 .");
					return null;
				}

				conn = (HttpURLConnection) url.openConnection();
				if (loginSession.getSessionid() != null) {
					conn.setRequestProperty("cookie",
							loginSession.getSessionid());
				} else {
					conn.setRequestProperty("cookie",
							app.myPreferences.getString("sessionid", ""));
				}
				// System.out.println("ships sessionid" + "===="
				// +app.myPreferences.getString("sessionid", ""));
				conn.setConnectTimeout(10000);

				InputStream inStream = conn.getInputStream();

				if (this.isCancelled()) {
					// print("线程取消 3.");
					inStream.close();
					return null;
				}

				parseHships(inStream,s);
				inStream.close();
				// print(uuid+" 获得数据。");
				// flag = true;
			} catch (Exception ex) {
				ex.printStackTrace();
			}
			return null;
		}
	}//更新highlightedships。高亮船舶。
	
	private static void print(String msg) {
		Log.i(TAG, msg);
	}

	public static final String TAG = "FileDownloader";

	public void getShipsInfo2(RotatedTileBox tb, PointF point,
			List<? super ShipsBean> res) {
		int r = (int) (12 * tb.getDensity());
		int ex = (int) point.x;
		int ey = (int) point.y;
//		double minla = tb.getRightBottomLatLon().getLatitude();
//		double maxlo = tb.getRightBottomLatLon().getLongitude();
//		double maxla = tb.getLeftTopLatLon().getLatitude();
//		double minlo = tb.getLeftTopLatLon().getLongitude();
		List<ShipsBean> _ships2 = new ArrayList<ShipsBean>();
		// if (allsearchshipsBeans != null
		// && allsearchshipsBeans.size() >= 1) {
		// for (int i = 0; i < allsearchshipsBeans.size(); i++) {
		// double sla = Double
		// .valueOf(allsearchshipsBeans.get(i).la);
		// double slo = Double
		// .valueOf(allsearchshipsBeans.get(i).lo);
		// if (sla > minla && sla < maxla && slo > minlo && slo < maxlo) {
		// _ships2.add(allsearchshipsBeans.get(i));
		// }
		// }
		// }
		// if (searchshipsBeans != null
		// && searchshipsBeans.size() >= 1) {
		// for (int i = 0; i < searchshipsBeans.size(); i++) {
		// double sla = Double
		// .valueOf(searchshipsBeans.get(i).la);
		// double slo = Double
		// .valueOf(searchshipsBeans.get(i).lo);
		// if (sla > minla && sla < maxla && slo > minlo && slo < maxlo) {
		// _ships2.add(searchshipsBeans.get(i));
		// }
		// }
		// }
		// 船队船舶
		// System.out.println("ready huoquchuanduichuanboxinxi!!!");
		if (app.myPreferences.getBoolean("isShowMyTeam", true)
				&& app.myPreferences.getBoolean("IsLogin", false)) {
			if (MyTeamShipsThread.currentshipsBeans.size() >= 1) {
				// for (int i = 0; i < MyTeamShipsThread.shipsBeans.size(); i++)
				// {
				// double sla =
				// Double.valueOf(MyTeamShipsThread.shipsBeans.get(i).la);
				// double slo =
				// Double.valueOf(MyTeamShipsThread.shipsBeans.get(i).lo);
				// if (sla > minla && sla < maxla && slo > minlo && slo < maxlo)
				// {
				// _ships2.add(MyTeamShipsThread.shipsBeans.get(i));
				// }
				// }
//				System.out
//						.println("huoquchuanduichuanboxinxi currentshipsBeans!!!");
				_ships2.addAll(MyTeamShipsThread.currentshipsBeans);
			} else {
				_ships2.addAll(MyTeamShipsThread.shipsBeans);
//				System.out.println("MyTeamShipsThread.shipsBeans!!!"
//						+ MyTeamShipsThread.shipsBeans.size());
			}
		}
			// 搜索船舶
			for (int s = 0; s < searchshipsBeans.size(); s++) {
				int c = 0;
				for (int cs = 0; cs < _ships2.size(); cs++) {
					if (_ships2.get(cs).m.equals(searchshipsBeans.get(s).m)) {
						c++;
						break;
					}
				}
				if (c == 0) {
					_ships2.add(searchshipsBeans.get(s));
				}
			}
			for (int s = 0; s < allsearchshipsBeans.size(); s++) {
				int c = 0;
				for (int cs = 0; cs < _ships2.size(); cs++) {
					if (_ships2.get(cs).m.equals(allsearchshipsBeans.get(s).m)) {
						c++;
						break;
					}
				}
				if (c == 0) {
					_ships2.add(allsearchshipsBeans.get(s));
				}
			}
		// 船队单个船舶//如果移动海图获取的是所有船队船舶就不需要了。
		// if (teamship != null && teamship.size() >= 1) {
		// for (int i = 0; i < teamship.size(); i++) {
		// double sla = Double
		// .valueOf(teamship.get(i).la);
		// double slo = Double
		// .valueOf(teamship.get(i).lo);
		// if (sla > minla && sla < maxla && slo > minlo && slo < maxlo) {
		// _ships2.add(teamship.get(i));
		// }
		// }
		// }
		// 点击的船舶
		for (int i = 0; i < alltap_ships.size(); i++) {
			// print("进入比较循环1");
			boolean alltap_shipshave = false;
			for (int j = 0; j < _ships2.size(); j++) {
				if (alltap_ships.get(i).m.equals(_ships2.get(j).m)) {
					// System.out.println("比例尺较小全部点击的无船队船舶");
					alltap_shipshave = true;
					break;
				}
			}
			if (!alltap_shipshave) {
				_ships2.add(alltap_ships.get(i));
				// print("增加所有点击船舶" + showArray.size());
			}
		}
		for (int j = 0; j < _ships2.size(); j++) {
			boolean tap_shipshave = false;
			// print("进入比较循环2"+tap_ships.size());
			if (tap_ships.size() >= 1) {
				// print("tap_ships不是空");
				if (_ships2.get(j).m.equals(tap_ships.get(0).m)) {
					// System.out.println("比例尺较小加入点击的无船队船舶");
					tap_shipshave = true;
					break;
				}
				if (!tap_shipshave) {
					_ships2.add(tap_ships.get(0));
					// print("增加点击船舶" + showArray.size());
				}
			}
			// print("结束比较循环2");
		}
		if (_ships2 != null && _ships2.size() >= 1) {
			for (ShipsBean n : _ships2) {
				if (tb == null)
					System.out.println("tb null!!!");
				int x = (int) tb.getPixXFromLatLon(n.getLa(), n.getLo());
				int y = (int) tb.getPixYFromLatLon(n.getLa(), n.getLo());
				if (calculateBelongs(ex, ey, x, y, r)) {
					res.add(n);
					break;// TODO ?
				}
			}
			_ships2.clear();
		}
	}

	public void getShipsInfo(RotatedTileBox tb, PointF point,
			List<? super ShipsBean> res) {
		int r = (int) (12 * tb.getDensity());
		int ex = (int) point.x;
		int ey = (int) point.y;
		double minla = tb.getRightBottomLatLon().getLatitude();
		double maxlo = tb.getRightBottomLatLon().getLongitude();
		double maxla = tb.getLeftTopLatLon().getLatitude();
		double minlo = tb.getLeftTopLatLon().getLongitude();
		List<ShipsBean> _ships2 = new ArrayList<ShipsBean>();
		// 搜索船舶//所有船舶包含则不用添加。
		// if (allsearchshipsBeans != null
		// && allsearchshipsBeans.size() >= 1) {
		// for (int i = 0; i < allsearchshipsBeans.size(); i++) {
		// double sla = Double
		// .valueOf(allsearchshipsBeans.get(i).la);
		// double slo = Double
		// .valueOf(allsearchshipsBeans.get(i).lo);
		// if (sla > minla && sla < maxla && slo > minlo && slo < maxlo) {
		// _ships2.add(allsearchshipsBeans.get(i));
		// }
		// }
		// }
		// if (searchshipsBeans != null
		// && searchshipsBeans.size() >= 1) {
		// for (int i = 0; i < searchshipsBeans.size(); i++) {
		// double sla = Double
		// .valueOf(searchshipsBeans.get(i).la);
		// double slo = Double
		// .valueOf(searchshipsBeans.get(i).lo);
		// if (sla > minla && sla < maxla && slo > minlo && slo < maxlo) {
		// _ships2.add(searchshipsBeans.get(i));
		// }
		// }
		// }
		// 船队单个船舶//如果移动海图获取的是所有船队船舶就不需要了。
		// if (teamship != null && teamship.size() >= 1) {
		// for (int i = 0; i < teamship.size(); i++) {
		// double sla = Double
		// .valueOf(teamship.get(i).la);
		// double slo = Double
		// .valueOf(teamship.get(i).lo);
		// if (sla > minla && sla < maxla && slo > minlo && slo < maxlo) {
		// _ships2.add(teamship.get(i));
		// }
		// }
		// }
		ArrayList<ShipsBean> _allships2Draw = new ArrayList<ShipsBean>();
		if (_ships2Draw != null) {
			_allships2Draw.addAll(_ships2Draw);
			// 所有船舶
			if (_allships2Draw != null && _allships2Draw.size() >= 1) {
				for (int ii = 0; ii < _allships2Draw.size(); ii++) {
					// _ships.get(ii);
					double sla = Double.valueOf(_allships2Draw.get(ii).la);
					double slo = Double.valueOf(_allships2Draw.get(ii).lo);
					if (sla > minla && sla < maxla && slo > minlo
							&& slo < maxlo) {
						_ships2.add(_allships2Draw.get(ii));
					}
				}
			}
			// 搜索船舶  没有就加上。
			if (MyTeamShipsThread.currentshipsBeans.size() >= 1) {
				for (int s = 0; s < MyTeamShipsThread.currentshipsBeans.size(); s++) {
					int c = 0;
					for (int cs = 0; cs < _ships2.size(); cs++) {
						if (_ships2.get(cs).m.equals(MyTeamShipsThread.currentshipsBeans.get(s).m)) {
							c++;
							break;
						}
					}
					if (c == 0) {
						_ships2.add(MyTeamShipsThread.currentshipsBeans.get(s));
					}
				}
//				_ships2.addAll(MyTeamShipsThread.currentshipsBeans);
			} else {
				for (int s = 0; s < MyTeamShipsThread.shipsBeans.size(); s++) {
					int c = 0;
					for (int cs = 0; cs < _ships2.size(); cs++) {
						if (_ships2.get(cs).m.equals(MyTeamShipsThread.shipsBeans.get(s).m)) {
							c++;
							break;
						}
					}
					if (c == 0) {
						_ships2.add(MyTeamShipsThread.shipsBeans.get(s));
					}
				}
//				_ships2.addAll(MyTeamShipsThread.shipsBeans);
			}
			for (int s = 0; s < searchshipsBeans.size(); s++) {
				int c = 0;
				for (int cs = 0; cs < _ships2.size(); cs++) {
					if (_ships2.get(cs).m.equals(searchshipsBeans.get(s).m)) {
						c++;
						break;
					}
				}
				if (c == 0) {
					_ships2.add(searchshipsBeans.get(s));
				}
			}
			for (int s = 0; s < allsearchshipsBeans.size(); s++) {
				int c = 0;
				for (int cs = 0; cs < _ships2.size(); cs++) {
					if (_ships2.get(cs).m.equals(allsearchshipsBeans.get(s).m)) {
						c++;
						break;
					}
				}
				if (c == 0) {
					_ships2.add(allsearchshipsBeans.get(s));
				}
			}
			// 点击的船舶
			for (int i = 0; i < alltap_ships.size(); i++) {
				// print("进入比较循环1");
				boolean alltap_shipshave = false;
				for (int j = 0; j < _ships2.size(); j++) {
					if (alltap_ships.get(i).m.equals(_ships2.get(j).m)) {
						// System.out.println("比例尺较小全部点击的无船队船舶");
						alltap_shipshave = true;
						break;
					}
				}
				if (!alltap_shipshave) {
					_ships2.add(alltap_ships.get(i));
					// print("增加所有点击船舶" + showArray.size());
				}
			}
			for (int j = 0; j < _ships2.size(); j++) {
				boolean tap_shipshave = false;
				// print("进入比较循环2"+tap_ships.size());
				if (tap_ships.size() >= 1) {
					// print("tap_ships不是空");
					if (_ships2.get(j).m.equals(tap_ships.get(0).m)) {
						// System.out.println("比例尺较小加入点击的无船队船舶");
						tap_shipshave = true;
						break;
					}
					if (!tap_shipshave) {
						_ships2.add(tap_ships.get(0));
						// print("增加点击船舶" + showArray.size());
					}
				}
				// print("结束比较循环2");
			}
		}
		if (_ships2 != null && _ships2.size() >= 1) {
			for (ShipsBean n : _ships2) {
				if (tb == null)
					System.out.println("tb null!!!");
				int x = (int) tb.getPixXFromLatLon(n.getLa(), n.getLo());
				int y = (int) tb.getPixYFromLatLon(n.getLa(), n.getLo());
				if (calculateBelongs(ex, ey, x, y, r)) {
					res.add(n);
					break;// TODO ?
				}
			}
			_ships2.clear();
		}
		
	}

	private boolean calculateBelongs(int ex, int ey, int objx, int objy,
			int radius) {
		return Math.abs(objx - ex) <= radius && (ey - objy) <= radius / 2
				&& (objy - ey) <= 3 * radius;
	}

	public void showPopupWindow(final View view, int ex, int ey,
			final ShipsBean fav) {
		// System.out.println("showPopupWindow");
		View contentView = LayoutInflater.from(view.getContext()).inflate(
				R.layout.balloon_overlay_ships, null);
		LinearLayout info = (LinearLayout) contentView
				.findViewById(R.id.balloon_main_layout);

		info.setOnClickListener(new OnClickListener() {

			@Override
			public void onClick(View arg0) {
				Intent intent = new Intent(view.getContext(),
						ShipInfoActivity.class);
				Bundle data = new Bundle();
				boolean myfleet = false;
				for (int i = 0; i < MyTeamShipsThread.shipsBeans.size(); i++) {
					if (fav.m.equals(MyTeamShipsThread.shipsBeans.get(i).m)) {
						myfleet = true;
					}
				}
				data.putString("myfleet", myfleet + "");
				data.putString("shipn", fav.n);
				data.putString("shipcs", fav.c);
				data.putString("shipcname", fav.cname);
				data.putString("shipm", fav.m);
				data.putString("shipi", fav.i);
				data.putString("shiplo", fav.lo);
				data.putString("shipla", fav.la);
				data.putString("shipco", fav.co);
				data.putString("shipsp", fav.sp);
				data.putString("shipt", fav.t);
				data.putString("ships", fav.s);
				data.putString("shipl", fav.l);
				data.putString("shipb", fav.b);
				data.putString("shipdr", fav.dr);
				data.putString("shipd", fav.d);
				data.putString("shipe", fav.e);
				data.putString("shipti", fav.ti);
				data.putString("shipan", fav.an);
				data.putString("shipc", fav.c);
				data.putString("shipdn", fav.dn);
				data.putString("shipflag", fav.flag);
				data.putString("shipfle", fav.fle);
				data.putString("shiph", fav.h);
				data.putString("shipmes", fav.message);
				data.putString("shiprot", fav.rot);
				intent.putExtras(data);
				view.getContext().startActivity(intent);
			}
		});
		TextView textShisName = (TextView) contentView
				.findViewById(R.id.text_ship_name);
		TextView textMmsi = (TextView) contentView.findViewById(R.id.text_mmsi);
		TextView textTime = (TextView) contentView.findViewById(R.id.text_time);
		final PopupWindow pop = new PopupWindow(contentView,
				LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, true);
		if (fav.cname!=null&&!fav.cname.equals("null")&&!fav.cname.equals("") && !fav.cname.equals("N/A")) {
			textShisName.setText(fav.cname);
		} else {
			if (fav.n==null||fav.n.equals("") || fav.n.equals("N/A")||fav.n.equals("null")) {
				textShisName.setText("暂无船名");
			} else {
				textShisName.setText(fav.n);
			}
		}
		textMmsi.setText("MMSI: " + fav.m);
		textTime.setText(fav.ti);
		pop.setFocusable(true);
		pop.setOutsideTouchable(true);
		pop.setBackgroundDrawable(new BitmapDrawable());

		int[] location = new int[2];
		view.getLocationOnScreen(location);
		pop.getContentView().measure(0, 0);
		pop.showAtLocation(view, Gravity.NO_GRAVITY, location[0] + ex
				- pop.getContentView().getMeasuredWidth() / 2, location[1] + ey
				- pop.getContentView().getMeasuredHeight());

	}

	private static List<afterShip> c = new ArrayList<afterShip>();

	public interface afterShip {
		public void shipRefresh(RotatedTileBox tileBox,
				ArrayList<ShipsBean> currentshipsBeans);
	}

	public void addafterShip(afterShip callas) {
		c.add(callas);
	}

	@Override
	public void destroyLayer() {
		// TODO Auto-generated method stub

	}

//	@Override
//	public void dotmapRefreshed(RotatedTileBox tileBox) {
//		// TODO Auto-generated method stub
//		this.tileBox = tileBox;
//		callDownloadShipsData(tileBox);
//	}
}
